"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ipaToVie = exports.syllableToVie = exports.vieConsonantRule = exports.addTonalMark = exports.addTonalMarkToVowel = void 0;
const constants_1 = require("./constants");
const parser_generated_1 = require("./parser.generated");
const addTonalMarkToVowel = (vie, tonalMark) => {
    let isAdded = false;
    let res = "";
    res = vie.replace(/ê|â|ă|ô|ơ|ư/i, (m) => {
        isAdded = true;
        return (m + tonalMark).normalize("NFC");
    });
    if (!isAdded) {
        res = vie.replace(/e|a|o|u|i/i, (m) => {
            isAdded = true;
            return (m + tonalMark).normalize("NFC");
        });
    }
    if (!isAdded) {
        res = vie.replace(/y/i, (m) => {
            return (m + tonalMark).normalize("NFC");
        });
    }
    return res;
};
exports.addTonalMarkToVowel = addTonalMarkToVowel;
const addTonalMark = (vie, isStress) => {
    if (/(ch|t|p|c)$/.test(vie)) {
        return (0, exports.addTonalMarkToVowel)(vie, isStress ? constants_1.COMBINE_ACUTE : constants_1.COMBINE_DOT);
    }
    else if (!isStress) {
        return (0, exports.addTonalMarkToVowel)(vie, constants_1.COMBINE_GRAVE);
    }
    else
        return vie;
};
exports.addTonalMark = addTonalMark;
const vieConsonantRule = (consonant, vowel) => {
    if (vowel &&
        consonant === "k" &&
        ["a", "o", "u"].includes(vowel[0].normalize("NFD")[0])) {
        return "c" + vowel;
    }
    if (vowel &&
        consonant === "c" &&
        ["e", "i"].includes(vowel[0].normalize("NFD")[0])) {
        return "k" + vowel;
    }
    return consonant + vowel;
};
exports.vieConsonantRule = vieConsonantRule;
const syllableToVie = ({ syllable, options, isLastSyllable, }) => {
    const isNullVowel = constants_1.ENDING_VOWEL_MAPPING[syllable.parts[1] ?? ""]
        ? false
        : true;
    let vieSyllable = `${constants_1.LETTER_MAPPING[syllable.parts[0] ?? ""] ?? ""}${constants_1.ENDING_VOWEL_MAPPING[syllable.parts[1] ?? ""] ?? constants_1.NULL_MAPPING}`.replace(/wi|wa|wâ|we|wơ|ge|gi(?!a)|gê|qui/g, (match) => {
        switch (match) {
            case "wi":
                return "uy";
            case "wa":
                return "oa";
            case "wâ":
                return "uâ";
            case "we":
                return "oe";
            case "wơ":
                return "uơ";
            case "ge":
                return "ghe";
            case "gi":
                return "ghi";
            case "gê":
                return "ghê";
            case "qui":
                return "quy";
            default:
                return "";
        }
    });
    if (isNullVowel) {
        if (options?.vowelEpenthesis?.skipAll ||
            (options?.vowelEpenthesis?.skipLast && isLastSyllable))
            return "";
        vieSyllable = vieSyllable.replace(/._/g, (m) => {
            return (0, exports.vieConsonantRule)(m[0], options?.vowelEpenthesis?.replacement ?? "ơ");
        });
    }
    else {
        vieSyllable = vieSyllable
            .replace(/ki$|li$|mi$|si$|ti$|hi$/g, (match) => {
            switch (match) {
                case "ki":
                    return "ky";
                case "li":
                    return "ly";
                case "mi":
                    return "my";
                case "si":
                    return "sy";
                case "ti":
                    return "ty";
                case "hi":
                    return "hy";
                default:
                    return "";
            }
        })
            .replace(/^k.|^c./g, (m) => (0, exports.vieConsonantRule)(m[0], m[1]));
    }
    const sylWithTonal = (0, exports.addTonalMark)(vieSyllable, syllable.stress);
    return options?.uppercaseStress && syllable.stress
        ? sylWithTonal.toLocaleUpperCase("vi")
        : sylWithTonal;
};
exports.syllableToVie = syllableToVie;
const ipaToVie = (ipa, options) => {
    return ipa.split(", ").flatMap((i) => {
        const cleaned = i.replaceAll("ɝˈ", "əˈɹ").replaceAll("ɝ", "əɹ");
        try {
            const ast = (0, parser_generated_1.parse)(cleaned);
            // console.log(
            //   cleaned,
            //   ast,
            //   ast.reduce((s, p) => s + (p.stress ? 1 : 0), 0),
            //   ast.reduce((s, p) => s + (p.parts[1] ? 1 : 0), 0)
            // );
            if (ast.reduce((s, p) => s + (p.stress ? 1 : 0), 0) ===
                ast.reduce((s, p) => s + (p.parts[1] ? 1 : 0), 0)) {
                const secondary = ast.find((p) => p.stress === 2);
                if (secondary) {
                    secondary.stress = undefined;
                }
            }
            // console.log(cleaned, ast);
            const lastSyllableIdx = ast.length - 1;
            const vie = ast.reduce((acc, syllable, idx) => {
                if (syllable.stress && !syllable.parts[1] && !!ast[idx + 1]) {
                    ast[idx + 1].stress = syllable.stress;
                    syllable.stress = undefined;
                }
                const vieSyl = (0, exports.syllableToVie)({
                    syllable,
                    options,
                    isLastSyllable: idx === lastSyllableIdx,
                });
                return acc + (idx !== 0 && !!vieSyl ? "-" : "") + vieSyl;
            }, "");
            return [{ ipa: i, ast, vie }];
        }
        catch (e) {
            console.error(e, "-------------", JSON.stringify([ipa, i, cleaned]));
        }
        return [];
    });
};
exports.ipaToVie = ipaToVie;
